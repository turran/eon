+ Make the theme be the theme files only
+ Move the register part of the theme to the drawer
+ Remove the wrapper element
+ We need to create some common code for widgets that are in fact compound widgets, like the color_button for example.
  Basically we need to create some kind of wrapper of the theme ender element which will just add the same properties
  the theme of the widgets that are used by the new widget has, or at least what it exposes. this way the theme editor
  will automatically have the new properties and wont need to create a new theme for it. On the widget case, we also need
  a way to handle such stuff automatically? or just let it do manually?
+ Refactor the widget to make the theme usage configurable
+ Add a simple widget one can inherit from to make "instances" of widgets, like an Ok button, a Cancel button, a Color button, etc.
+ Add parent, sibling, etc information on every eon element, we need that for focus handling
+ Add events to the input, the input should trigger events whenever something happens, like a new focus element or a new grabbed element. This input event should be registered
  on the window? on the input?
+ Now that we are building more widgets we need a way to actually set themes based on its class/child-parent relation, maybe we can create something similar to css?
+ Add a scaler element, the scaler should be an element that can scale renderers or other elements by using a WIP property on enesim called scale which should scale the geometry not the final rendering process, ie. before applying the transformation matrix
+ Change the static const attributes on the different basic theme implementation into properties
+ List of widgets we should have:
  button (DONE)
  radio (DONE)
  checkbox (DONE)
  frame (DONE)
  image (DONE)
  progressbar (DONE)
  scrollbar (DONE) (maybe rename it to slider???)
  scrollview (DONE)
  spinner
  slider (DONE)
  notebook
  treeview
  table
  combobox
+ The theme interface should be called from the core elements directly, without passing through escen, the escen code should be moved on the theme system
  this way whenever we decide to create a svg based theme, we create a new theme which follows the theme interface, loads the escen and provides the renderer
  in case the esvg elements are no longer renderers
+ We should not call any escen function from the core elements, basically the "correct" design should be:
  code elements (enders) ---> theme (theme element) ---> theme engine (escen, xml, whatever) ---> theme implementation (like the basic one we have)
                          A                          B                                        C
  Where A should be a direct call, i.e eon_theme_element_foo_set, eon_theme_element_state_set, whatever
  Where B should be eon_theme_engine_property_set(element, enum). in the case of escen, the enum should match to a string for now given that escen does not handle
  direct integer properties yet
  Where C should be escen calling the correct object and set its properties, animations whatever
+ Cache every escen state a widget needs, to avoid having to fetch the state each time something changes
