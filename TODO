+ Refactor the widget to make the theme usage configurable
+ Add the "enabled" property on the widgets
+ Add parent, sibling, etc information on every eon element, we need that for focus handling
+ Add events to the input, the input should trigger events whenever something happens, like a new focus element or a new grabbed element. This input event should be registered
  on the window? on the input?
+ Now that we are building more widgets we need a way to actually set themes based on its class/child-parent relation, maybe we can create something similar to css?
+ Add a scaler element, the scaler should be an element that can scale renderers or other elements by using a WIP property on enesim called scale which should scale the geometry not the final rendering process, ie. before applying the transformation matrix
+ Change the static const attributes on the different basic theme implementation into properties
+ Remove every width/height/x/y/ callback on the descriptors, use the size/position where possible
+ List of widgets we should have:
  button (DONE)
  radio (DONE)
  checkbox (DONE)
  frame (DONE)
  image (DONE)
  progressbar (DONE)
  scrollbar (DONE) (maybe rename it to slider???)
  scrollview (DONE)
  spinner
  slider (DONE)
  notebook
  treeview
  table
  combobox
+ The theme interface should be called from the core elements directly, without passing through escen, the escen code should be moved on the theme system
  this way whenever we decide to create a svg based theme, we create a new theme which follows the theme interface, loads the escen and provides the renderer
  in case the esvg elements are no longer renderers
+ We should not call any escen function from the core elements, basically the "correct" design should be:
  code elements (enders) ---> theme (theme element) ---> theme engine (escen, xml, whatever) ---> theme implementation (like the basic one we have)
                          A                          B                                        C
  Where A should be a direct call, i.e eon_theme_element_foo_set, eon_theme_element_state_set, whatever
  Where B should be eon_theme_engine_property_set(element, enum). in the case of escen, the enum should match to a string for now given that escen does not handle
  direct integer properties yet
  Where C should be escen calling the correct object and set its properties, animations whatever
+ We can create a simple way of handling direct property set/get, on the ender generator, whenever a property is added, the return property can be managed
  as an external Ender_Property so then, we can handle the direct property set
+ Cache every escen state a widget needs, to avoid having to fetch the state each time something changes
+ We need to avoid having to go through the list of widgets that much, one to check if the widget needs a setup, another to do the setup, another for the cleanup, etc, etc, etc
